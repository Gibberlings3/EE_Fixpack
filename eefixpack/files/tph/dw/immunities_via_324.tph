/*

When 'write' is set to 1, files to be edited are autogenerated, and then recorded in folders data/immunity/bg2 (or similar, it's game-dependent).
When 'write' is set to 0, we instead use the recorded data.
The idea is to set write=1 in development and then put write=0 in live code.

In either case, there's a manually-generated list of immunities in %MOD_FOLDER%/data/immunity/bg2/offensive_manual.txt

When 'in_fixpack' is set to 0, the code runs idempotently and doesn't record its edits. (This can be used by later mods to update the immunity structure for mod-added items.)

Dependencies: needs detectable spells to be loaded.
*/

DEFINE_ACTION_FUNCTION immunities_via_324
	INT_VAR write=0
		in_fixpack=1
	STR_VAR data_location="%MOD_FOLDER%/data/immunity"
BEGIN

	ACTION_IF !in_fixpack BEGIN
		OUTER_SET write=1 // a little confusing to be sure: we don't actually want to write, but we want to autogenerate a list of files rather than using the pregen
	END

	ACTION_IF GAME_IS iwdee BEGIN
		OUTER_SPRINT path "iwd"
	END ELSE
	ACTION_IF GAME_IS bgee BEGIN
		ACTION_IF GAME_INCLUDES sod BEGIN
			OUTER_SPRINT path "sod"
		END ELSE BEGIN
			OUTER_SPRINT path "bg1"
		END
	END ELSE BEGIN
		OUTER_SPRINT path "bg2"
	END
	OUTER_SPRINT path "%data_location%/%path%"


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// define the immunities
// in hindsight it was a mistake to use hardcoded entries, it
// potentially messes with other people's code. We'll use ds_resolve_stat.
//
// Note that the IDS name entry for the immunity is not referenced
// elsewhere.
//////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////


	<<<<<<<< .../fp-inline/immunities.2da
	2DA V1.0
			opcode		id
	1		5			CHARM_IMMUNITY
	2		39			SLEEP_IMMUNITY
	3		45			STUN_IMMUNITY
	4		24			PANIC_IMMUNITY
	5		128			CONFUSION_IMMUNITY
	6		175			HOLD_IMMUNITY
	7		157			WEB_IMMUNITY
	8		154			ENTANGLE_IMMUNITY
	9		134			PETRIFY_IMMUNITY
	10		238			DISINTEGRATE_IMMUNITY
	11		38			SILENCE_IMMUNITY
	12		76			FEEBLEMIND_IMMUNITY
	13		16			HASTE_IMMUNITY
	14		40			SLOW_IMMUNITY
	15		13			DEATH_IMMUNITY
	16		minorglobe	MINOR_GLOBE
	17		majorglobe	MAJOR_GLOBE
	>>>>>>>>

	COPY - ".../fp-inline/immunities.2da" nowhere
		SPRINT to_append ""
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW immune_entries colcount
		FOR (row=0;row<immune_entries;++row) BEGIN
			READ_2DA_ENTRY_FORMER immune_entries row 1 opcode
			READ_2DA_ENTRY_FORMER immune_entries row 2 id
			LPF ds_resolve_stat STR_VAR id RET stat_ind END
			SET $opcode_splstate_map("%opcode%")=stat_ind
		END

////////////////////////////////////////////////////////////////////////
// load an opcode map for EFF files
////////////////////////////////////////////////////////////////////////

	COPY_EXISTING_REGEXP - ".*\.eff" nowhere
		SPRINT resref "%SOURCE_RES%"
		TO_UPPER resref
		SET $eff_opcodes("%resref%")=LONG_AT 0x10

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// hand out the immunities to equipped items
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
// bulk allocation to items and spells
//
////////////////////////////////////////////////////////////////////////

	ACTION_IF write BEGIN
		ACTION_CLEAR_ARRAY output_array_itm
		ACTION_CLEAR_ARRAY output_array_spl
		COPY_EXISTING_REGEXP ".*\.\(itm\|spl\)" override
			LPF apply_324_to_protective_object RET modified END
			PATCH_IF modified BEGIN
				PATCH_IF "%SOURCE_EXT%" STR_EQ "itm" BEGIN
					SPRINT $output_array_itm("%SOURCE_FILE%") ""
				END ELSE BEGIN
					SPRINT $output_array_spl("%SOURCE_FILE%") ""
				END
			END
		BUT_ONLY
		ACTION_SORT_ARRAY_INDICES output_array_itm LEXICOGRAPHICALLY
		ACTION_SORT_ARRAY_INDICES output_array_spl LEXICOGRAPHICALLY
		OUTER_SPRINT output ""
		ACTION_PHP_EACH output_array_itm AS resource=>discard BEGIN
			OUTER_SPRINT output "%output%%resource%%WNL%"
		END
		ACTION_PHP_EACH output_array_spl AS resource=>discard BEGIN
			OUTER_SPRINT output "%output%%resource%%WNL%"
		END
		COPY + ".../fp-inline/blank" "%path%/protective.txt"
			INSERT_BYTES 0x0 STRING_LENGTH "%output%"
			WRITE_ASCII 0x0 "%output%"
	END ELSE
	ACTION_IF FILE_EXISTS "%path%/protective.txt" BEGIN
		COPY - "%path%/protective.txt" nowhere
			READ_2DA_ENTRIES_NOW protective_entries 1
			PATCH_PRINT "Patching %protective_entries% files..."
			PATCH_SILENT
			FOR (row=0;row<protective_entries;++row) BEGIN
				READ_2DA_ENTRY_FORMER protective_entries row 0 resource
				INNER_ACTION BEGIN
					ACTION_IF FILE_EXISTS_IN_GAME "%resource%" BEGIN
						COPY_EXISTING "%resource%" override
							LPF apply_324_to_protective_object END
						BUT_ONLY
					END ELSE BEGIN
						WARN "immunities_via_324 tried to add spellstates to (supposed) protective object %resource%, but it doesn't exist"
					END
				END
			END
			PATCH_VERBOSE
			PATCH_PRINT "...done"

	END ELSE BEGIN
		FAIL "immunities_via_324 is running in read mode (write=0) but there is no protective.txt file at path %path%"
	END

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//// Roll out the protection onto actual spells
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////


// do this here because we don't want repetitions in the immunity items

	OUTER_SET $opcode_splstate_map("209")=$opcode_splstate_map("13") // Death Immunity protects from PW:Kill
	OUTER_SET $opcode_splstate_map("55")=$opcode_splstate_map("13") // Death Immunity protects from 'kill target'
	OUTER_SET $opcode_splstate_map("210")=$opcode_splstate_map("45") // Stun Immunity protects from PW:Stun
	OUTER_SET $opcode_splstate_map("217")=$opcode_splstate_map("39") // Unconsciousness Immunity protects from PW:Sleep


////////////////////////////////////////////////////////////
//// Apply handcoded changes, stored in the file 'offensive_manual.txt'
//// and distinct for each game
/////////////////////////////////////////////////////////////

	ACTION_IF FILE_EXISTS "%path%/offensive_manual.txt" BEGIN
		COPY - "%path%/offensive_manual.txt" nowhere
			READ_2DA_ENTRIES_NOW offensive_manual_entries 3
			PATCH_PRINT "Patching %offensive_manual_entries% files..."
			PATCH_SILENT
			FOR (row=1;row<offensive_manual_entries;++row) BEGIN
				READ_2DA_ENTRY_FORMER offensive_manual_entries row 0 resource
				READ_2DA_ENTRY_FORMER offensive_manual_entries row 1 match_opcode
				READ_2DA_ENTRY_FORMER offensive_manual_entries row 2 block_opcode
				parameter1=$opcode_splstate_map("%block_opcode%")
				INNER_ACTION BEGIN
					ACTION_IF FILE_EXISTS_IN_GAME "%resource%" BEGIN
						COPY_EXISTING "%resource%" override
							PATCH_IF !in_fixpack BEGIN
								LPF DELETE_EFFECT INT_VAR match_opcode=324 match_parameter1=parameter1 match_parameter2=110 END
							END
							LPF CLONE_EFFECT INT_VAR multi_match=1 duration=0 timing=0 match_opcode parameter1 parameter2=110 opcode=324 STR_VAR resource="%SOURCE_RES%" insert=first END
							PATCH_IF write BEGIN
								TO_LOWER resource
								SPRINT $processed("%resource%") ""
							END
						BUT_ONLY
					END ELSE BEGIN
						WARN "immunities_via_324 tried to add spellstates to (supposed) protective object %resource%, but it doesn't exist"
					END
				END

			END
			PATCH_VERBOSE
			PATCH_PRINT "...done"
	END ELSE BEGIN
		WARN "immunities_via_324 could not find offensive_manual.txt at path %path%"
	END

////////////////////////////////////////////////////////////
//// Autoapply that works whenever the effect
//// block contains only the opcode+cosmetic states after it
/////////////////////////////////////////////////////////////

	ACTION_IF write BEGIN
		ACTION_CLEAR_ARRAY output_array_itm
		ACTION_CLEAR_ARRAY output_array_spl
		COPY_EXISTING_REGEXP ".*\.\(itm\|spl\)" override
			SPRINT resource "%SOURCE_FILE%"
			TO_LOWER resource
			PATCH_IF !VARIABLE_IS_SET $processed("%resource%") BEGIN
				LPF apply_324_to_offensive_object RET modified END
				PATCH_IF modified BEGIN
					PATCH_IF "%SOURCE_EXT%" STR_EQ "itm" BEGIN
						SPRINT $output_array_itm("%SOURCE_FILE%") ""
					END ELSE BEGIN
						SPRINT $output_array_spl("%SOURCE_FILE%") ""
					END
				END
			END
		BUT_ONLY
		ACTION_SORT_ARRAY_INDICES output_array_itm LEXICOGRAPHICALLY
		ACTION_SORT_ARRAY_INDICES output_array_spl LEXICOGRAPHICALLY
		OUTER_SPRINT output ""
		ACTION_PHP_EACH output_array_itm AS resource=>discard BEGIN
			OUTER_SPRINT output "%output%%resource%%WNL%"
		END
		ACTION_PHP_EACH output_array_spl AS resource=>discard BEGIN
			OUTER_SPRINT output "%output%%resource%%WNL%"
		END
		COPY + ".../fp-inline/blank" "%path%/offensive.txt"
			INSERT_BYTES 0x0 STRING_LENGTH "%output%"
			WRITE_ASCII 0x0 "%output%"
	END ELSE BEGIN
		ACTION_IF FILE_EXISTS "%path%/offensive.txt" BEGIN
			COPY - "%path%/offensive.txt" nowhere
				READ_2DA_ENTRIES_NOW offensive_entries 1
				PATCH_PRINT "Patching %offensive_entries% files..."
				PATCH_SILENT
				FOR (row=0;row<offensive_entries;++row) BEGIN
					READ_2DA_ENTRY_FORMER offensive_entries row 0 resource
					INNER_ACTION BEGIN
						ACTION_IF FILE_EXISTS_IN_GAME "%resource%" BEGIN
							COPY_EXISTING "%resource%" override
								LPF apply_324_to_offensive_object END
							BUT_ONLY
						END ELSE BEGIN
							WARN "immunities_via_324 tried to add spellstates to (supposed) offensive object %resource%, but it doesn't exist"
						END
					END
				END
				PATCH_VERBOSE
				PATCH_PRINT "...done"

		END ELSE BEGIN
			FAIL "immunities_via_324 is running in read mode (write=0) but there is no offensive.txt file at path %path%"
		END


	END


/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//// Now do MGI/GI
////
//// Those spells MGI protects against get a 324 for MINOR_GLOBE
//// Those GI but not MGI protects againsts get a 324 for MAJOR_GLOBE
//// And we strip the 206s
////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////


	// get the 206'd spells from MGI
	ACTION_CLEAR_ARRAY mgi_spells

	COPY_EXISTING - "spwi406.spl" nowhere
		GET_OFFSET_ARRAY ab_arr SPL_V10_HEADERS
		GET_OFFSET_ARRAY2 fx_arr ab_arr_0 SPL_V10_HEAD_EFFECTS
		PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
			PATCH_IF SHORT_AT fx_off=206 BEGIN
				READ_ASCII (fx_off+0x14) resource
				TO_LOWER resource
				SPRINT $mgi_spells("%resource%") ""
			END
		END
	BUT_ONLY

	// get the 206'd spells from GI
	ACTION_CLEAR_ARRAY gi_spells

	COPY_EXISTING - "spwi602.spl" nowhere
		GET_OFFSET_ARRAY ab_arr SPL_V10_HEADERS
		GET_OFFSET_ARRAY2 fx_arr ab_arr_0 SPL_V10_HEAD_EFFECTS
		PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
			PATCH_IF SHORT_AT fx_off=206 BEGIN
				READ_ASCII (fx_off+0x14) resource
				TO_LOWER resource
				PATCH_IF !VARIABLE_IS_SET $mgi_spells("%resource%") BEGIN
					SPRINT $gi_spells("%resource%") ""
				END
			END
		END
	BUT_ONLY

	// mark them up

	ACTION_PHP_EACH mgi_spells AS resref=>discard BEGIN
		COPY_EXISTING "%resref%.spl" override
			PATCH_IF !in_fixpack BEGIN
				LPF DELETE_EFFECT INT_VAR match_opcode=324 match_parameter1=$opcode_splstate_map("minorglobe") match_parameter2=110 END
			END
			LPF ADD_SPELL_EFFECT INT_VAR insert_point=0 opcode=324 target=2 parameter1=$opcode_splstate_map("minorglobe") parameter2=110 STR_VAR resource="%SOURCE_RES%" END
			PATCH_IF in_fixpack BEGIN
				LPF fp_log_this STR_VAR file="mgi_spells.txt" input="%SOURCE_RES%" END
			END
		IF_EXISTS
	END
	ACTION_PHP_EACH gi_spells AS resref=>discard BEGIN
		COPY_EXISTING "%resref%.spl" override
			PATCH_IF !in_fixpack BEGIN
				LPF DELETE_EFFECT INT_VAR match_opcode=324 match_parameter1=$opcode_splstate_map("majorglobe") match_parameter2=110 END
			END
			LPF ADD_SPELL_EFFECT INT_VAR insert_point=0 opcode=324 target=2 parameter1=$opcode_splstate_map("majorglobe") parameter2=110 STR_VAR resource="%SOURCE_RES%" END
			PATCH_IF in_fixpack BEGIN
				LPF fp_log_this STR_VAR file="gi_spells.txt" input="%SOURCE_RES%" END
			END
		IF_EXISTS
	END
	// mark up actual immunity spells

	ACTION_FOR_EACH spell IN
		spin736 // in BGEE, this just casts MGI - hence the silent=1 clause
		spwi406
		spwm126
	BEGIN
		COPY_EXISTING "%spell%.spl" override
			LPF DELETE_EFFECT INT_VAR match_opcode=206 END
			PATCH_IF !in_fixpack BEGIN
				LPF DELETE_EFFECT INT_VAR match_opcode=328 match_parameter2=$opcode_splstate_map("minorglobe") END
			END
			LPF CLONE_EFFECT INT_VAR silent=1 match_opcode=102 multi_match=1 parameter2=$opcode_splstate_map("minorglobe") opcode=328 special=1 STR_VAR insert=first END
		IF_EXISTS
	END

	ACTION_FOR_EACH spell IN
		jwglobe
		spwi602
		spwi954
	BEGIN
		COPY_EXISTING "%spell%.spl" override
			LPF DELETE_EFFECT INT_VAR match_opcode=206 END
			PATCH_IF !in_fixpack BEGIN
				LPF DELETE_EFFECT INT_VAR match_opcode=328 match_parameter2=$opcode_splstate_map("minorglobe") END
				LPF DELETE_EFFECT INT_VAR match_opcode=328 match_parameter2=$opcode_splstate_map("majorglobe") END
			END
			LPF CLONE_EFFECT INT_VAR match_opcode=102 multi_match=1 parameter2=$opcode_splstate_map("minorglobe") opcode=328 special=1 STR_VAR insert=first END
			LPF CLONE_EFFECT INT_VAR match_opcode=102 multi_match=1 parameter2=$opcode_splstate_map("majorglobe") opcode=328 special=1 STR_VAR insert=first END
		IF_EXISTS
	END

///// end of main function

END

/////////////////////////////////////////////////////////////
//// The core function used to put 324s onto protective spells/items
////
//// Assumes opcode_splstate_map loaded
////
//// Does not need any information about the file being patched
/////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION apply_324_to_protective_object
	RET modified
BEGIN
		has_206=0
		modified=0
		// this will be painfully slow with CLONE_EFFECT unless we check first what we're looking for
		PHP_EACH opcode_splstate_map AS opcode=>discard BEGIN
			SET $immunity_search_map("%opcode%")=0
		END
		PATCH_IF "%SOURCE_EXT%" STR_EQ "itm" BEGIN
			GET_OFFSET_ARRAY fx_arr ITM_V10_GEN_EFFECTS
			PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
				PATCH_IF SHORT_AT fx_off = 101 BEGIN
					READ_LONG (fx_off+0x8) opcode
					PATCH_IF VARIABLE_IS_SET $immunity_search_map("%opcode%") BEGIN
						SET $immunity_search_map("%opcode%")=1
					END
				END ELSE
				PATCH_IF !has_206 && SHORT_AT fx_off=206 BEGIN
					has_206=1
				END
			END
		END
		PATCH_IF "%SOURCE_EXT%" STR_EQ "itm" BEGIN
			GET_OFFSET_ARRAY ab_arr ITM_V10_HEADERS
		END ELSE BEGIN
			GET_OFFSET_ARRAY ab_arr SPL_V10_HEADERS
			END
		PHP_EACH ab_arr AS ab_ind=>ab_off BEGIN
			GET_OFFSET_ARRAY2 fx_arr ab_off ITM_V10_HEAD_EFFECTS // NB, same for spl and itm
			PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
				PATCH_IF SHORT_AT fx_off = 101 BEGIN
					READ_LONG (fx_off+0x8) opcode
					PATCH_IF VARIABLE_IS_SET $immunity_search_map("%opcode%") BEGIN
						SET $immunity_search_map("%opcode%")=1
					END
				END ELSE
				PATCH_IF !has_206 && SHORT_AT fx_off=206 BEGIN
					has_206=1
				END
			END
		END
		// ok, now do the clones
		PHP_EACH immunity_search_map AS this_opcode=>check BEGIN
			PATCH_IF check BEGIN
				parameter2=$opcode_splstate_map("%this_opcode%")
				PATCH_IF !in_fixpack BEGIN
					LPF DELETE_EFFECT INT_VAR match_opcode=328 match_parameter2=parameter2 END
				END
				LPF CLONE_EFFECT INT_VAR match_opcode=101 match_parameter2=this_opcode opcode=328 special=1 parameter2 STR_VAR insert=first END
				modified=1
			END
		END
		// now delete any 206s that are now redundant
		PATCH_IF has_206 BEGIN
			PATCH_IF "%SOURCE_EXT%" STR_EQ itm BEGIN
				GET_OFFSET_ARRAY fx_arr ITM_V10_GEN_EFFECTS
				PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
					PATCH_IF SHORT_AT fx_off=206 BEGIN
						LPF immunity_delete_redundant_206s INT_VAR fx_off END
					END
				END
			END

			PATCH_IF "%SOURCE_EXT%" STR_EQ itm BEGIN
				GET_OFFSET_ARRAY ab_arr ITM_V10_HEADERS
			END ELSE BEGIN
				GET_OFFSET_ARRAY ab_arr SPL_V10_HEADERS
			END
			PHP_EACH ab_arr AS ab_ind=>ab_off BEGIN
				GET_OFFSET_ARRAY2 fx_arr ab_off ITM_V10_HEAD_EFFECTS
				PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
					PATCH_IF SHORT_AT fx_off=206 BEGIN
						LPF immunity_delete_redundant_206s INT_VAR fx_off END
					END
				END
			END
			LPF DELETE_EFFECT INT_VAR match_opcode=999 END // actually enact the deletions
		END
END


/////////////////////////////////////////////////////////////
//// The core function used to automatically assign 324 blocks
//// to an offensive spell or item
/////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION apply_324_to_offensive_object
	RET modified
BEGIN
	modified=0
	PATCH_IF "%SOURCE_EXT%" STR_EQ "itm" BEGIN
		GET_OFFSET_ARRAY ab_arr ITM_V10_HEADERS
	END ELSE BEGIN
		GET_OFFSET_ARRAY ab_arr SPL_V10_HEADERS
		END
	PHP_EACH ab_arr AS ab_ind=>ab_off BEGIN
		GET_OFFSET_ARRAY2 fx_arr ab_off ITM_V10_HEAD_EFFECTS // NB, same for spl and itm
		// first check if there's a unique opcode from the list
		number_of_matches=0
		current_opcode="-1"
		PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
			READ_SHORT fx_off opcode
			PATCH_IF opcode=177 BEGIN
				READ_ASCII fx_off+0x14 eff
				TO_UPPER eff
				PATCH_IF VARIABLE_IS_SET $eff_opcodes("%eff%") BEGIN
					opcode=$eff_opcodes("%eff%")
				END
			END
			PATCH_IF VARIABLE_IS_SET $opcode_splstate_map("%opcode%") BEGIN
				PATCH_IF !(opcode=current_opcode) BEGIN
					++number_of_matches
					current_opcode=opcode
				END
			END
		END
		PATCH_IF number_of_matches>1 BEGIN
			LPF fp_log_this INT_VAR repeat=0 STR_VAR file=multiple_effects_for_immunity.txt input="%SOURCE_FILE%" END
		END ELSE
		PATCH_IF number_of_matches=1 BEGIN
			PATCH_IF current_opcode=39 BEGIN // sleep/unconsciousnes, treat separately
				PATCH_IF write && in_fixpack BEGIN
					LPF fp_log_this INT_VAR repeat=0 STR_VAR file=opcode_39_effects.txt input="%SOURCE_FILE%" END
				END
			END ELSE BEGIN
				// go through the other opcodes and check for non-cosmetic effects
				non_cosmetic=0
				reached_payload_opcode=0
				payload_is_177=0
				SPRINT insert "first"
				PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
					READ_SHORT fx_off opcode
					PATCH_IF opcode=177 BEGIN
						READ_ASCII fx_off+0x14 eff
						TO_UPPER eff
						PATCH_IF VARIABLE_IS_SET $eff_opcodes("%eff%") BEGIN
							opcode=$eff_opcodes("%eff%")
						END
						currently_177=1
					END ELSE BEGIN
						currently_177=0
					END
					PATCH_MATCH "%opcode%" WITH
					"%current_opcode%"
					BEGIN
						reached_payload_opcode=1
						PATCH_IF currently_177 BEGIN
							SPRINT current_eff "%eff%"
							payload_is_177=1
						END
					END
					7 8 50 61 66 141 142 139 165 174 206 215 287 318 324 BEGIN
					END
					23 106 BEGIN// panic-related opcodes
						PATCH_IF !current_opcode=24 BEGIN
							non_cosmetic=1
						END
					END
					DEFAULT
						PATCH_IF reached_payload_opcode BEGIN
							non_cosmetic=1
						END ELSE BEGIN
							SPRINT insert "above" // if there are non-cosmetic opcodes above the payload opcode,
												  // we need immunity only once the payload is reached
						END
					END
				END
				PATCH_IF !non_cosmetic && reached_payload_opcode BEGIN
					parameter1=$opcode_splstate_map("%current_opcode%")
					PATCH_IF !in_fixpack BEGIN
						LPF DELETE_EFFECT INT_VAR header=ab_ind match_opcode=324 match_parameter1=parameter1 match_parameter2=110 END
					END
					PATCH_IF payload_is_177 BEGIN
						LPF CLONE_EFFECT INT_VAR header=ab_ind multi_match=1 duration=0 timing=0 match_opcode=177 parameter1 parameter2=110 opcode=324 STR_VAR match_resource="%current_eff%" resource="%SOURCE_RES%" insert END
						PATCH_IF write BEGIN
							LPF fp_log_this INT_VAR repeat=0 STR_VAR file=177_offensive_for_immunity.txt input="%SOURCE_FILE%" END
						END
					END ELSE BEGIN
						LPF CLONE_EFFECT INT_VAR header=ab_ind multi_match=1 duration=0 timing=0 match_opcode=current_opcode parameter1 parameter2=110 opcode=324 STR_VAR resource="%SOURCE_RES%" insert END
					END
					PATCH_IF write BEGIN
						modified=1
					END
				END ELSE BEGIN
					PATCH_IF write && in_fixpack BEGIN
						LPF fp_log_this INT_VAR repeat=0 STR_VAR file=complex_effects_for_immunity.txt input="%SOURCE_FILE% %current_opcode%" END
						PATCH_IF currently_177 BEGIN
							LPF fp_log_this INT_VAR repeat=0 STR_VAR file=complex_effects_for_immunity_177.txt input="%SOURCE_FILE% %current_opcode%" END
						END
					END
				END
			END
		END

	END
END


/////////////////////////////////////////////////////////////
//// Define a function to remove redundant 206s
//// using the array 'immunity_check_array' to check which
//// 101s are present
////
//// Yes, this violates code/data separation; so sue me.
/////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION immunity_delete_redundant_206s
	INT_VAR fx_off=0
BEGIN
	READ_ASCII (fx_off+0x14) resource
	PATCH_MATCH "%resource%" WITH
		SPWI305 // haste x 4
		SPRA301
		SPIN828
		SPIN 572
		SPWI613 // improved haste
	BEGIN
		delete=$immunity_search_map(16)
	END
		SPIN575 // vortex web
	BEGIN
		delete=$immunity_search_map(157)
	END
		SPWI312 // slow
		SPWISH25
		SPIN983
		SPWM164
		SPIN977 // Golem slow
	BEGIN
		delete=$immunity_search_map(40)
	END
		SPWM111 // entangle
		SPPR105
		SPIN688 // plant growth
		CDSW1H58 // not-actually-implemented Sword of Mask secspell
		CDMOUND // not-actually-implemented Shambling Mound weapon subspell
		CDHGNYA1 // not-actually-implemented secspell on Nyalee's staff
	BEGIN
		delete=$immunity_search_map(154)
	END
	DEFAULT
		delete=0
	END
	PATCH_IF delete BEGIN
		WRITE_SHORT fx_off 999 // mark for deletion
	END

END

