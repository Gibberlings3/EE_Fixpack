/*
Cahir had asked if there was a way to get the latest updates from the Beamdog translation tool,
made by the Polish translation team, into a Game Text Update. This monstrosity is the result.

Basic idea is simple: use the 'download tlk' feature from the translation tool, grab the
corresponding tlk from a *clean* 2.6 install, set some vars in the function and it'll compare
the two and generate a GTU-style tra file. The tra file can then get run through component
999 to make the corresponding tph for the GTU.

It batches 1000 strings at a go--going one-by-one was painfully slow, and I didn't want to press
my luck with more. The result is a pretty quick balance--run time for the three Polish tlk
comparisons was under a minute.

I don't know what WeiDU does with line breaks between reading a string in ASCII and trying to
APPEND it to a file, but a good 90% of this project was me banging my head against it. Double
breaks became single breaks, or single breaks became double, or single breaks deleted the
windows/sys32 folder. In the end it's a super-ugly workaround, but it works and the brick wall
is substantially harder than my head, so meh. If someone has a slicker way to do this, by all
means, go for it!

One to-do for future versions: recognize when it's working on SoD and doing the split at
strref 34000 automatically. The Polish one was done manually.

Initial iteration 10.26.2022
  - initial coding, passing results to Cahir to see what can be improved

*/

/////                                                  \\\\\
///// cd_tlk_comparator                                \\\\\
/////                                                  \\\\\

// this function process a tra file into string_sets based on the tra reference, e.g. @123 is used as STRING_SET 123 @123
// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_ACTION_FUNCTION cd_tlk_comparator
  INT_VAR f_tlk_exists = 0            // set to 1 if it's a language with dialogf.tlk
  STR_VAR m_tlk_26       = ~~         // male/sole tlk that ships with 2.6 (full path with extension)
          m_tlk_tool     = ~~         // male/sole tlk from the Beamdog tool (full path with extension)
          f_tlk_26       = ~~         // female tlk that ships with 2.6 (full path with extension)
          f_tlk_tool     = ~~         // female tlk from the Beamdog tool (full path with extension)
          output         = ~lang.tra~ // will be output, sans backup, into the eefixpack folder
BEGIN

  ACTION_IF ((!FILE_EXISTS ~%m_tlk_26%~) OR (!FILE_EXISTS ~%m_tlk_tool%~) OR ((!FILE_EXISTS ~%f_tlk_26%~) AND f_tlk_exists) OR ((!FILE_EXISTS ~%f_tlk_tool%~) AND f_tlk_exists)) BEGIN
    FAIL ~one of the required tlks not found~
  END

  MKDIR ~weidu_external/eefixpack/tlk_temp~

<<<<<<<<./inline/output.tra
// this file has been automatically generated by SECRET COMPONENT 998
>>>>>>>>

  COPY ~./inline/output.tra~ ~weidu_external/eefixpack/tlk_temp/%output%~

  COPY ~%m_tlk_26%~ ~%m_tlk_26%~
    READ_LONG 0x0a entries
    READ_LONG 0x0e ~%SOURCE_RES%_base_off~

  COPY ~%m_tlk_tool%~ ~%m_tlk_tool%~
    READ_LONG 0x0e ~%SOURCE_RES%_base_off~

  ACTION_IF f_tlk_exists BEGIN

    COPY ~%f_tlk_26%~ ~%f_tlk_26%~
      READ_LONG 0x0e ~%SOURCE_RES%_base_off~

    COPY ~%f_tlk_tool%~ ~%f_tlk_tool%~
      READ_LONG 0x0e ~%SOURCE_RES%_base_off~

  END ELSE BEGIN

    OUTER_SPRINT f_tlk_26_snd ~~  // lazy way to make these always match in comparison below
    OUTER_SPRINT f_tlk_26_contents ~~
    OUTER_SPRINT f_tlk_tool_snd ~~
    OUTER_SPRINT f_tlk_tool_contents ~~

  END

//OUTER_SET entries = 7000 // limit for testing
OUTER_SET thou_limit = (entries / 1000) + 1
OUTER_SET rmdr = (entries MODULO 1000)

  OUTER_FOR (index_lg = 0 ; index_lg < thou_limit ; ++index_lg) BEGIN

    ACTION_IF index_lg = (thou_limit - 1) BEGIN OUTER_SET sm_limit = rmdr END ELSE BEGIN OUTER_SET sm_limit = 1000 END

    // now load up 1000 entries
    ACTION_FOR_EACH tlk IN m_tlk_26 m_tlk_tool BEGIN

      COPY ~%%tlk%%~ ~%%tlk%%~
        FOR (index = (1000 * index_lg) ; index < ((1000 * index_lg) + sm_limit) ; ++index) BEGIN
          READ_ASCII (0x12 + 0x02 + (index * 0x1a)) ~%tlk%_%index%_snd~
          READ_LONG  (0x12 + 0x12 + (index * 0x1a)) off
          READ_LONG  (0x12 + 0x16 + (index * 0x1a)) length
          READ_ASCII (~%%SOURCE_RES%_base_off%~ + off) ~%tlk%_%index%_contents~ (length)
        END
        BUT_ONLY

    END

    ACTION_IF f_tlk_exists BEGIN

      ACTION_FOR_EACH tlk IN f_tlk_26 f_tlk_tool BEGIN

        COPY ~%%tlk%%~ ~%%tlk%%~
          FOR (index = (1000 * index_lg) ; index < ((1000 * index_lg) + sm_limit) ; ++index) BEGIN
            READ_ASCII (0x12 + 0x02 + (index * 0x1a)) ~%tlk%_%index%_snd~
            READ_LONG  (0x12 + 0x12 + (index * 0x1a)) off
            READ_LONG  (0x12 + 0x16 + (index * 0x1a)) length
            READ_ASCII (~%%SOURCE_RES%_base_off%~ + off) ~%tlk%_%index%_contents~ (length)
          END
          BUT_ONLY

      END

    END

    OUTER_FOR (index = (1000 * index_lg) ; index < ((1000 * index_lg) + sm_limit) ; ++index) BEGIN // now compare the 1000 entries we're working with

      OUTER_SPRINT debug ~~
      OUTER_SPRINT m_tlk_26_snd        EVALUATE_BUFFER ~%m_tlk_26_%index%_snd%~
      OUTER_SPRINT m_tlk_tool_snd      EVALUATE_BUFFER ~%m_tlk_tool_%index%_snd%~
      OUTER_SPRINT m_tlk_26_contents   EVALUATE_BUFFER ~%m_tlk_26_%index%_contents%~
      OUTER_SPRINT m_tlk_tool_contents EVALUATE_BUFFER ~%m_tlk_tool_%index%_contents%~
      ACTION_IF (~%m_tlk_26_snd%~      STRING_COMPARE_CASE ~%m_tlk_tool_snd%~) BEGIN OUTER_SPRINT debug ~%debug% main tlk sound reference mismatch;~ END // sound mismatch in m tlk
      ACTION_IF (~%m_tlk_26_contents%~ STRING_COMPARE ~%m_tlk_tool_contents%~) BEGIN OUTER_SPRINT debug ~%debug% main tlk contents mismatch;~ END // sound mismatch in m tlk // text mismatch in m tlk

      ACTION_IF f_tlk_exists BEGIN
        OUTER_SPRINT f_tlk_26_snd        EVALUATE_BUFFER ~%f_tlk_26_%index%_snd%~
        OUTER_SPRINT f_tlk_tool_snd      EVALUATE_BUFFER ~%f_tlk_tool_%index%_snd%~
        OUTER_SPRINT f_tlk_26_contents   EVALUATE_BUFFER ~%f_tlk_26_%index%_contents%~
        OUTER_SPRINT f_tlk_tool_contents EVALUATE_BUFFER ~%f_tlk_tool_%index%_contents%~
        ACTION_IF (~%f_tlk_26_snd%~      STRING_COMPARE_CASE ~%f_tlk_tool_snd%~) BEGIN OUTER_SPRINT debug ~%debug% female tlk sound reference mismatch;~ END // sound mismatch in m tlk
        ACTION_IF (~%f_tlk_26_contents%~ STRING_COMPARE ~%f_tlk_tool_contents%~) BEGIN OUTER_SPRINT debug ~%debug% female tlk contents mismatch;~ END // text mismatch in f tlk
      END

      ACTION_IF (~%debug%~ STRING_COMPARE_CASE ~~) BEGIN
        OUTER_INNER_PATCH_SAVE m_tlk_tool_contents ~%m_tlk_tool_contents%~ BEGIN
          REPLACE_TEXTUALLY ~%LNL%~ ~CD_LINE_BREAK~ // line breaks get fubar'd
          REPLACE_TEXTUALLY ~%MNL%~ ~CD_LINE_BREAK~ // line breaks get fubar'd
        END
        ACTION_IF f_tlk_exists BEGIN
          OUTER_INNER_PATCH_SAVE f_tlk_tool_contents ~%f_tlk_tool_contents%~ BEGIN
            REPLACE_TEXTUALLY ~%LNL%~ ~CD_LINE_BREAK~ // line breaks get fubar'd
            REPLACE_TEXTUALLY ~%MNL%~ ~CD_LINE_BREAK~ // line breaks get fubar'd
          END
          APPEND_OUTER ~weidu_external/eefixpack/tlk_temp/%output%~ "//%debug%CD_LINE_BREAK@%index% = ~%m_tlk_tool_contents%~CD_LINE_BREAK~%f_tlk_tool_contents%~CD_LINE_BREAK[%m_tlk_tool_snd%]"
        END ELSE BEGIN
          APPEND_OUTER ~weidu_external/eefixpack/tlk_temp/%output%~ "//%debug%CD_LINE_BREAK@%index% = ~%m_tlk_tool_contents%~ [%m_tlk_tool_snd%]"
        END
      END

    END

  END

  COPY + ~weidu_external/eefixpack/tlk_temp/%output%~ ~eefixpack/%output%~
    REPLACE_TEXTUALLY ~CD_LINE_BREAK~ ~%WNL%~ // line breaks get fubar'd

END
