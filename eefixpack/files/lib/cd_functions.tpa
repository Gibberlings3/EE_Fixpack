/////                                                  \\\\\
///// cd_string_set_from_tra                           \\\\\
/////                                                  \\\\\

// this function process a tra file into string_sets based on the tra reference, e.g. @123 is used as STRING_SET 123 @123
// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_ACTION_FUNCTION cd_string_set_from_tra
  INT_VAR cd_mode    = 1  // set to 0 will generate tph files; 1 will build and execute them
  STR_VAR input_tra  = ~~ // tra file to process
          output_tph = ~~ // tph being built; use weidu_external for this
BEGIN

  ACTION_IF FILE_EXISTS ~%input_tra%~ BEGIN // skip sod for non-bgee

<<<<<<<<./inlined/blank.txt
>>>>>>>>
    COPY ~./inlined/blank.txt~ ~%output_tph%~

    ACTION_IF !cd_mode BEGIN

      APPEND_OUTER ~%output_tph%~ "// this file is automatically generated by SECRET COMPONENT 999 from %input_tra% - there is no need to manually update it"

    END

    APPEND_OUTER ~%output_tph%~ "WITH_TRA ~%input_tra%~ BEGIN STRING_SET"

    COPY ~%input_tra%~ ~%input_tra%~
      REPLACE_EVALUATE ~^\([ %TAB%]*@\)\([0-9]+\)\([ %TAB%]*=\)~ BEGIN
        INNER_ACTION BEGIN
          APPEND_OUTER ~%output_tph%~ ~  %MATCH2% @%MATCH2%~
        END
      END ~%MATCH1%%MATCH2%%MATCH3%~
      BUT_ONLY

    APPEND_OUTER ~%output_tph%~ ~END~

    ACTION_IF cd_mode BEGIN

      INCLUDE ~%output_tph%~

    END

  END

END

/////                                                  \\\\\
///// alter_header                                     \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/alter_header.tpa~

/////                                                  \\\\\
///// alter_store_item                                 \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/alter_store_item.tpa~

/////                                                  \\\\\
///// ALTER_AREA/CREATURE_ITEM                         \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/alter_area-creature_item.tpa~

/////                                                  \\\\\
///// miscellaneous creature inventory macros          \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/fixpack_inventory_misc.tpa~

// found by Ardanis in Rogue Rebalancing, had apparently been written by Nythrun
// fixed two things, wrapped a function over it

DEFINE_PATCH_FUNCTION ~FJ_SPL_ITM_REINDEX~ BEGIN

  PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.spl~) BEGIN
    hs = 0x28
    WRITE_LONG 0xc ~-1~ //Identified name
    WRITE_LONG 0x54 ~-1~ //Identified description
    PATCH_FOR_EACH tz IN 0x44 0x48 0x58 0x5c BEGIN
      WRITE_LONG tz 0
    END
  END ELSE PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.itm~) BEGIN
    hs = 0x38
  END
  READ_LONG 0x64 hf //Extended header offset
  READ_SHORT 0x68 hc //Extended header count
  READ_LONG 0x6a fb //Feature block table offset
  READ_SHORT 0x70 fc //Feature block count
  PATCH_IF ((hf > fb) AND (hc > 0)) BEGIN // Ardanis: fixed "hc > 1" to "hc > 0"
    READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
    PATCH_IF (~%eh%~ STRING_EQUAL ~fail~) BEGIN
      WHILE ((~%eh%~ STRING_EQUAL ~fail~) AND (hc > 0)) BEGIN
        READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
        hc -= 1
      END
    END
    DELETE_BYTES hf (hs * hc)
    hf = 0x72
    WRITE_LONG 0x64 hf
    WRITE_SHORT 0x68 hc
    fb = (0x72 + (hs * hc))
    WRITE_LONG 0x6a fb
    PATCH_IF !(~%eh%~ STRING_EQUAL ~fail~) BEGIN
      INSERT_BYTES hf (hs * hc)
      WRITE_ASCIIE hf ~%eh%~
    END
  END ELSE PATCH_IF ((hf != 0x72) AND (hc = 0)) BEGIN
    hf = 0x72
    WRITE_LONG 0x64 hf
  END
  FOR (i1 = 0; i1 < (hs * hc); i1 += hs) BEGIN
    WRITE_SHORT (hf + i1 + 0x20) fc
    READ_SHORT (hf + i1 + 0x1e) cx
    fc += cx
  END
  PATCH_IF (SOURCE_SIZE > (0x72 + (hs * hc) + (0x30 * fc))) BEGIN
    DELETE_BYTES (0x72 + (hs * hc) + (0x30 * fc)) (SOURCE_SIZE - (0x72 + (hs * hc) + (0x30 * fc)))
  END

  // added by Ardanis
  WRITE_SHORT 0x6e 0

END // end of function

/////                                                  \\\\\
///// level-o-matic stuff                              \\\\\
/////                                                  \\\\\

OUTER_SET round = 6
ACTION_IF game_is_iwdee BEGIN OUTER_SET cap = 30 END ELSE BEGIN OUTER_SET cap = 20 END
INCLUDE ~eefixpack/files/lib/cd_level_select-o-matic.tpa~

/////                                                  \\\\\
///// cd_make_subspell                                 \\\\\
/////                                                  \\\\\

DEFINE_PATCH_MACRO ~cd_make_subspell~ BEGIN
  WRITE_LONG 0x08 "-1" // blank name
  WRITE_LONG 0x50 "-1" // blank desc
  WRITE_ASCII 0x22 ~~ #6 // blank casting anim, school, secondary
  LPF ALTER_HEADER INT_VAR projectile = 1 END
  LPF ALTER_EFFECT INT_VAR power = 0 resist_dispel = 0 savingthrow = 0 END
END

/////                                                  \\\\\
///// cd_move_actor action/patch function              \\\\\
/////                                                  \\\\\

DEFINE_ACTION_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
  STR_VAR area  = "none" // area to patch w/o .are extension

BEGIN

  COPY_EXISTING ~%area%.are~ ~override~
    LPF cd_move_actor INT_VAR old_x old_y new_x new_y END
    BUT_ONLY IF_EXISTS // formally, should ACTION_IF with a WARNING if %area%.are not found... but meh

END

DEFINE_PATCH_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
BEGIN

  READ_LONG  0x54 actor_off
  READ_SHORT 0x58 actor_num
  FOR (index = 0 ; index < actor_num ; ++index) BEGIN
    READ_SHORT (actor_off + 0x20 + (index * 0x110)) test_x
    READ_SHORT (actor_off + 0x22 + (index * 0x110)) test_y
    PATCH_IF ((test_x = old_x) AND (test_y = old_y)) BEGIN
      WRITE_SHORT (actor_off + 0x20 + (index * 0x110)) new_x // location
      WRITE_SHORT (actor_off + 0x22 + (index * 0x110)) new_y
      WRITE_SHORT (actor_off + 0x24 + (index * 0x110)) new_x // destination
      WRITE_SHORT (actor_off + 0x26 + (index * 0x110)) new_y
    END
  END

END

/////                                                  \\\\\
///// cd_define_area_vertices                          \\\\\
/////                                                  \\\\\

/*
angel found a number of opened doors with broken/missing vertices, and fixes
them in his MiH Fixes & Restorations. Unfortunately, they were fixed with SFO
so they needed to be converted to bogstandard functions. This function allow
you to alter the vertices of any area structure--containers, regions, or the
four sets of vertices used by doors--by deleting the existing vertices and
using an external cd_define_area_vertices_array for the new vertices. This
array *must* be defined prior to the function launch.

The bounding box and launch points are optional to specify, though the
bounding box values are ignored for impeded door vertices since they don't
have a bounding box.
*/

DEFINE_PATCH_FUNCTION cd_define_area_vertices
  INT_VAR bounding_left   = "-1" // optional
          bounding_top    = "-1" // optional
          bounding_right  = "-1" // optional
          bounding_bottom = "-1" // optional
          launch_point_x  = "-1" // optional
          launch_point_y  = "-1" // optional
  STR_VAR struct_name  = ~~ // required: name of the door/region/container to be patched
          struct_type  = ~~ // required with allowed values: container, region, door_open, door_closed, door_impeded_open, door_impeded_closed
BEGIN

  SET door_internal = "-1"
  PATCH_IF ("%struct_type%" STRING_COMPARE_REGEXP "door_\(open\|closed\|impeded_open\|impeded_closed\)" = 0) BEGIN // any door
    READ_LONG  0xa4 struct_num
    READ_LONG  0xa8 struct_off
    SET struct_length = 0xc8
    SET local_launch_off = 0x74
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_open" = 0) BEGIN // open door
      SET local_bound_off = 0x38
      SET local_vert_idx_off = 0x2c
      SET local_vert_num_off = 0x30
      SET door_internal = 4
    END ELSE
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_closed" = 0) BEGIN // closed door
      SET local_bound_off = 0x40
      SET local_vert_idx_off = 0x34
      SET local_vert_num_off = 0x32
      SET door_internal = 3
    END ELSE
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_impeded_open" = 0) BEGIN // open, impeded door
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x48
      SET local_vert_num_off = 0x4c
      SET door_internal = 2
    END ELSE BEGIN // closed, impeded door
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x50
      SET local_vert_num_off = 0x4e
      SET door_internal = 1
    END
  END ELSE
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container" = 0) BEGIN // container
    SET local_bound_off = 0x38
    SET local_vert_idx_off = 0x54
    SET local_vert_num_off = 0x50
    SET local_launch_off = 0x34
    READ_SHORT 0x74 struct_num
    READ_LONG  0x70 struct_off
    SET struct_length = 0xc0
    SET door_internal = 0
  END ELSE
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region" = 0) BEGIN // region/trigger
    SET local_bound_off = 0x22
    SET local_vert_idx_off = 0x2c
    SET local_vert_num_off = 0x2a
    SET local_launch_off = 0x70
    READ_SHORT 0x5a struct_num
    READ_LONG  0x5c struct_off
    SET struct_length = 0xc4
    SET door_internal = 0
  END
  PATCH_IF door_internal < 0 BEGIN
    PATCH_PRINT ~ == No changes made with cd_define_area_vertices: Unknown structure type specified (%struct_type%)~
  END ELSE BEGIN
    SET vert_delta = 0
    READ_LONG  0x7c vert_off
    READ_SHORT 0x80 vert_num
    FOR (index = 0 ; index < struct_num ; ++index) BEGIN
      READ_ASCII (struct_off + 0x00 + (index * struct_length)) name_check (32) NULL
      PATCH_IF ("%name_check%" STRING_COMPARE_CASE "%struct_name%") BEGIN // NOT the matched door/region/container
        PATCH_IF vert_delta != 0 BEGIN // don't bother if number of vertices hasn't changed (yet)
          PATCH_IF door_internal = 0 BEGIN // update container/region
            WRITE_LONG (struct_off + local_vert_idx_off + (index * struct_length)) THIS + vert_delta // update vertex index
          END ELSE BEGIN // update four door indices
            WRITE_LONG (struct_off + 0x2c + (index * struct_length)) THIS + vert_delta // open door vertex index
            WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed door vertex index
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta // impeded-open door vertex index
            WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta // impeded-closed door vertex index
          END
        END
      END ELSE BEGIN // matched door/region/container
        PATCH_IF local_bound_off != 0 BEGIN // skip for impeded doors
          PATCH_IF bounding_left >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x00 + (index * struct_length)) bounding_left   // set the new bounding box
          END
          PATCH_IF bounding_top >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x02 + (index * struct_length)) bounding_top    // set the new bounding box
          END
          PATCH_IF bounding_right >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x04 + (index * struct_length)) bounding_right  // set the new bounding box
          END
          PATCH_IF bounding_bottom >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x06 + (index * struct_length)) bounding_bottom // set the new bounding box
          END
        END
        PATCH_IF launch_point_x >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x00 + (index * struct_length)) launch_point_x    // set the new x launch coordinates
        END
        PATCH_IF launch_point_y >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x02 + (index * struct_length)) launch_point_y    // set the new y launch coordinates
        END
        READ_LONG   (struct_off + local_vert_idx_off + (index * struct_length)) struct_vert_idx
        READ_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num
        PATCH_IF struct_vert_num != 0 BEGIN // delete old vertices first
          DELETE_BYTES (vert_off + (0x04 * struct_vert_idx)) (struct_vert_num * 0x04)
          SET vert_delta -= struct_vert_num
          SET struct_vert_num = 0
        END
        PATCH_PHP_EACH cd_define_area_vertices_array AS coords => foo BEGIN
          INSERT_BYTES (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) 0x04
          WRITE_SHORT  (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_0
          WRITE_SHORT  (vert_off + 0x02 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_1
          SET struct_vert_num += 1
          SET vert_delta += 1
        END
        WRITE_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num
        // since doors have four vertex indices, may need additional vertex index updates for anything other than the last one (impeded-closed)
        PATCH_IF door_internal > 1 BEGIN      // impeded-open, closed, or open
          WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta     // impeded-closed index
          PATCH_IF door_internal > 2  BEGIN   // closed or open
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta   // impeded-open index
            PATCH_IF door_internal > 3  BEGIN // open
              WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed index
            END
          END
        END // bonus door check
      END // match name check
    END // end structure loop

    // now, to check everything else that uses vertices and update their indices if are listed after the new insertions/deletions
    PATCH_IF vert_delta != 0 BEGIN // don't bother if same number of vertices
      PATCH_FOR_EACH offset IN 0x54 0x5c 0x60 0x68 0x70 0x78 /* 0x7c */ 0x84 0x88 0x90 0xa0 0xa8 0xb0 0xb8 0xbc 0xc0 0xc4 0xcc BEGIN
        READ_LONG offset off_check
        PATCH_IF off_check > vert_off BEGIN // if section is after vertices, adjust accordingly
          WRITE_LONG offset (THIS + (0x04 * vert_delta))
        END
      END
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region") BEGIN // update region indices for containers/door patches
        READ_SHORT 0x5a region_num
        READ_LONG  0x5c region_off
        FOR (index = 0 ; index < region_num ; ++index) BEGIN
          READ_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN
            WRITE_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx + vert_delta
          END
        END
      END
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container") BEGIN // update container indices for region/door patches
        READ_SHORT 0x74 cont_num
        READ_LONG  0x70 cont_off
        FOR (index = 0 ; index < cont_num ; ++index) BEGIN
          READ_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN
            WRITE_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx + vert_delta
          END
        END
      END
      PATCH_IF !door_internal BEGIN // update door indices for container/region patches
        READ_LONG 0xa4 door_num
        READ_LONG 0xa8 door_off
        FOR (index = 0 ; index < door_num ; ++index) BEGIN
          PATCH_FOR_EACH local_off IN 0x2c 0x34 0x48 0x50 BEGIN // checks open door index, closed door index, impeded-open index, impeded-closed index
            READ_LONG (door_off + local_off + (index * 0xc8)) vert_idx
            PATCH_IF vert_idx > struct_vert_idx BEGIN
              WRITE_LONG (door_off + local_off + (index * 0xc8)) vert_idx + vert_delta
            END
          END
        END
      END
      WRITE_SHORT 0x80 vert_num + vert_delta
    END // vert_delta check

  END // end valid structure check

END

/////                                                  \\\\\
///// cd_swap_actor_name                               \\\\\
/////                                                  \\\\\

DEFINE_ACTION_FUNCTION cd_swap_actor_name
  STR_VAR old_name = ""
          new_name = ""
          area     = ""
BEGIN

  ACTION_IF (("%old_name%" STRING_COMPARE_CASE "") AND (FILE_EXISTS_IN_GAME ~%area%.are~)) BEGIN

    COPY_EXISTING ~%area%.are~ ~override~
      READ_LONG  0x54 act_off
      READ_SHORT 0x58 act_num
      FOR (index = 0 ; index < act_num ; ++index) BEGIN
        READ_ASCII (act_off + 0x00 + (index * 0x110)) name (32) NULL
        PATCH_IF ("%old_name%" STRING_COMPARE_CASE "%name%" = 0) BEGIN
          WRITE_ASCIIE (act_off + 0x00 + (index * 0x110)) ~%new_name%~ #32
          SET index = act_num // kill loop
        END
      END
      BUT_ONLY

  END

END

/////                                                  \\\\\
///// cd_bulk_fix_item_strings_bulk                    \\\\\
/////                                                  \\\\\

// mini-macro for the bulk item fixes, string updates
DEFINE_PATCH_MACRO cd_bulk_fix_item_strings_bulk BEGIN

  FOR (index = 0x54 ; index > 0x4f ; index -= 0x04) BEGIN // only if no identified descript to match and update, go after normal descript (blun04)
    READ_LONG index desc_strref
    PATCH_IF ((desc_strref >= 0) AND (desc_strref < 999999)) BEGIN
      READ_STRREF index desc
      INNER_PATCH_SAVE desc ~%desc%~ BEGIN
        PATCH_IF (IS_AN_INT params_4) BEGIN
          REPLACE_TEXTUALLY ~%itm_speed_text%~ ~\1%params_4%~
        END
        PATCH_IF (IS_AN_INT params_5) BEGIN
          REPLACE_TEXTUALLY ~%itm_weight_text%~ ~\1%params_5%~
        END
        PATCH_IF (IS_AN_INT params_6) BEGIN
          REPLACE_TEXTUALLY ~%itm_thac0_text%~ ~\1%params_6%~
        END
      END
      INNER_ACTION BEGIN
        STRING_SET_EVALUATE desc_strref ~%desc%~
      END
      SET index = 0 // kill loop (if identified updated, don't mess with unidentified)
    END
  END

END
