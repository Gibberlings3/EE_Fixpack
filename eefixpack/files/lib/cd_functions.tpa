/////                                                  \\\\\
///// cd_string_set_from_tra                           \\\\\
/////                                                  \\\\\

// this function process a tra file into string_sets based on the tra reference, e.g. @123 is used as STRING_SET 123 @123
// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_ACTION_FUNCTION cd_string_set_from_tra
  INT_VAR cd_mode    = 1  // set to 0 will generate tph files; 1 will build and execute them
  STR_VAR input_tra  = ~~ // tra file to process
          output_tph = ~~ // tph being built; use weidu_external for this
BEGIN

  ACTION_IF FILE_EXISTS ~%input_tra%~ BEGIN // skip sod for non-bgee
  
<<<<<<<<./inlined/blank.txt
>>>>>>>>
    COPY ~./inlined/blank.txt~ ~%output_tph%~
    
    ACTION_IF !cd_mode BEGIN
    
      APPEND_OUTER ~%output_tph%~ "// this file is automatically generated by SECRET COMPONENT 999 from %input_tra% - there is no need to manually update it"
      
    END
    
    APPEND_OUTER ~%output_tph%~ "WITH_TRA ~%input_tra%~ BEGIN STRING_SET"
    
    COPY ~%input_tra%~ ~%input_tra%~
      REPLACE_EVALUATE ~^\([ %TAB%]*@\)\([0-9]+\)\([ %TAB%]*=\)~ BEGIN
        INNER_ACTION BEGIN
          APPEND_OUTER ~%output_tph%~ ~  %MATCH2% @%MATCH2%~
        END  
      END ~%MATCH1%%MATCH2%%MATCH3%~
      BUT_ONLY
      
    APPEND_OUTER ~%output_tph%~ ~END~
    
    ACTION_IF cd_mode BEGIN
      
      INCLUDE ~%output_tph%~
      
    END  
    
  END

END

/////                                                  \\\\\
///// alter_header                                     \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/alter_header.tpa~

/////                                                  \\\\\
///// alter_store_item                                 \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/alter_store_item.tpa~

/////                                                  \\\\\
///// ALTER_AREA/CREATURE_ITEM                         \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/alter_area-creature_item.tpa~

/////                                                  \\\\\
///// miscellaneous creature inventory macros          \\\\\
/////                                                  \\\\\

INCLUDE ~eefixpack/files/lib/fixpack_inventory_misc.tpa~

// found by Ardanis in Rogue Rebalancing, had apparently been written by Nythrun
// fixed two things, wrapped a function over it

DEFINE_PATCH_FUNCTION ~FJ_SPL_ITM_REINDEX~ BEGIN

  PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.spl~) BEGIN
    hs = 0x28
    WRITE_LONG 0xc ~-1~ //Identified name
    WRITE_LONG 0x54 ~-1~ //Identified description
    PATCH_FOR_EACH tz IN 0x44 0x48 0x58 0x5c BEGIN
      WRITE_LONG tz 0
    END
  END ELSE PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.itm~) BEGIN
    hs = 0x38
  END
  READ_LONG 0x64 hf //Extended header offset
  READ_SHORT 0x68 hc //Extended header count
  READ_LONG 0x6a fb //Feature block table offset
  READ_SHORT 0x70 fc //Feature block count
  PATCH_IF ((hf > fb) AND (hc > 0)) BEGIN // Ardanis: fixed "hc > 1" to "hc > 0"
    READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
    PATCH_IF (~%eh%~ STRING_EQUAL ~fail~) BEGIN
      WHILE ((~%eh%~ STRING_EQUAL ~fail~) AND (hc > 0)) BEGIN
        READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
        hc -= 1
      END
    END
    DELETE_BYTES hf (hs * hc)
    hf = 0x72
    WRITE_LONG 0x64 hf
    WRITE_SHORT 0x68 hc
    fb = (0x72 + (hs * hc))
    WRITE_LONG 0x6a fb
    PATCH_IF !(~%eh%~ STRING_EQUAL ~fail~) BEGIN
      INSERT_BYTES hf (hs * hc)
      WRITE_ASCIIE hf ~%eh%~
    END
  END ELSE PATCH_IF ((hf != 0x72) AND (hc = 0)) BEGIN
    hf = 0x72
    WRITE_LONG 0x64 hf
  END
  FOR (i1 = 0; i1 < (hs * hc); i1 += hs) BEGIN
    WRITE_SHORT (hf + i1 + 0x20) fc
    READ_SHORT (hf + i1 + 0x1e) cx
    fc += cx
  END
  PATCH_IF (SOURCE_SIZE > (0x72 + (hs * hc) + (0x30 * fc))) BEGIN
    DELETE_BYTES (0x72 + (hs * hc) + (0x30 * fc)) (SOURCE_SIZE - (0x72 + (hs * hc) + (0x30 * fc)))
  END

  // added by Ardanis
  WRITE_SHORT 0x6e 0

END // end of function

/////                                                  \\\\\
///// level-o-matic stuff                              \\\\\
/////                                                  \\\\\

OUTER_SET round = 6
ACTION_IF game_is_iwdee BEGIN OUTER_SET cap = 30 END ELSE BEGIN OUTER_SET cap = 20 END 
INCLUDE ~eefixpack/files/lib/cd_level_select-o-matic.tpa~

/////                                                  \\\\\
///// cd_make_subspell                                 \\\\\
/////                                                  \\\\\

DEFINE_PATCH_MACRO ~cd_make_subspell~ BEGIN
  WRITE_LONG 0x08 "-1" // blank name
  WRITE_LONG 0x50 "-1" // blank desc
  WRITE_ASCII 0x22 ~~ #6 // blank casting anim, school, secondary
  LPF ALTER_HEADER INT_VAR projectile = 1 END
  LPF ALTER_EFFECT INT_VAR power = 0 resist_dispel = 0 savingthrow = 0 END
END  

/////                                                  \\\\\
///// cd_move_actor action/patch function              \\\\\
/////                                                  \\\\\

DEFINE_ACTION_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
  STR_VAR area  = "none" // area to patch w/o .are extension
  
BEGIN

  COPY_EXISTING ~%area%.are~ ~override~ 
    LPF cd_move_actor INT_VAR old_x old_y new_x new_y END
    BUT_ONLY IF_EXISTS // formally, should ACTION_IF with a WARNING if %area%.are not found... but meh
    
END

DEFINE_PATCH_FUNCTION cd_move_actor

  INT_VAR old_x = "-1" // old coordinates for matching
          old_y = "-1"
          new_x = "-1" // new coordinates
          new_y = "-1"
BEGIN

  READ_LONG  0x54 actor_off
  READ_SHORT 0x58 actor_num
  FOR (index = 0 ; index < actor_num ; ++index) BEGIN
    READ_SHORT (actor_off + 0x20 + (index * 0x110)) test_x
    READ_SHORT (actor_off + 0x22 + (index * 0x110)) test_y
    PATCH_IF ((test_x = old_x) AND (test_y = old_y)) BEGIN
      WRITE_SHORT (actor_off + 0x20 + (index * 0x110)) new_x // location
      WRITE_SHORT (actor_off + 0x22 + (index * 0x110)) new_y
      WRITE_SHORT (actor_off + 0x24 + (index * 0x110)) new_x // destination
      WRITE_SHORT (actor_off + 0x26 + (index * 0x110)) new_y
    END
  END

END

/////                                                  \\\\\
///// cd_define_area_vertices                          \\\\\
/////                                                  \\\\\

/* 
angel found a number of opened doors with broken/missing vertices, and fixes
them in his MiH Fixes & Restorations. Unfortunately, they were fixed with SFO
so they needed to be converted to bogstandard functions. This function allow 
you to alter the vertices of any area structure--containers, regions, or the 
four sets of vertices used by doors--by deleting the existing vertices and 
using an external cd_define_area_vertices_array for the new vertices. This 
array *must* be defined prior to the function launch. 

The bounding box and launch points are optional to specify, though the 
bounding box values are ignored for impeded door vertices since they don't 
have a bounding box. 
*/

DEFINE_PATCH_FUNCTION cd_define_area_vertices
  INT_VAR bounding_left   = "-1" // optional
          bounding_top    = "-1" // optional
          bounding_right  = "-1" // optional
          bounding_bottom = "-1" // optional 
          launch_point_x  = "-1" // optional
          launch_point_y  = "-1" // optional
  STR_VAR struct_name  = ~~ // required: name of the door/region/container to be patched
          struct_type  = ~~ // required with allowed values: container, region, door_open, door_closed, door_impeded_open, door_impeded_closed
BEGIN

  SET door_internal = "-1"
  PATCH_IF ("%struct_type%" STRING_COMPARE_REGEXP "door_\(open\|closed\|impeded_open\|impeded_closed\)" = 0) BEGIN // any door
    READ_LONG  0xa4 struct_num
    READ_LONG  0xa8 struct_off
    SET struct_length = 0xc8
    SET local_launch_off = 0x74
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_open" = 0) BEGIN // open door  
      SET local_bound_off = 0x38
      SET local_vert_idx_off = 0x2c
      SET local_vert_num_off = 0x30
      SET door_internal = 4
    END ELSE 
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_closed" = 0) BEGIN // closed door  
      SET local_bound_off = 0x40
      SET local_vert_idx_off = 0x34
      SET local_vert_num_off = 0x32
      SET door_internal = 3
    END ELSE  
    PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "door_impeded_open" = 0) BEGIN // open, impeded door  
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x48
      SET local_vert_num_off = 0x4c
      SET door_internal = 2
    END ELSE BEGIN // closed, impeded door
      SET local_bound_off = 0
      SET local_vert_idx_off = 0x50
      SET local_vert_num_off = 0x4e
      SET door_internal = 1
    END   
  END ELSE 
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container" = 0) BEGIN // container  
    SET local_bound_off = 0x38
    SET local_vert_idx_off = 0x54
    SET local_vert_num_off = 0x50
    SET local_launch_off = 0x34
    READ_SHORT 0x74 struct_num
    READ_LONG  0x70 struct_off
    SET struct_length = 0xc0
    SET door_internal = 0
  END ELSE 
  PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region" = 0) BEGIN // region/trigger 
    SET local_bound_off = 0x22
    SET local_vert_idx_off = 0x2c
    SET local_vert_num_off = 0x2a
    SET local_launch_off = 0x70
    READ_SHORT 0x5a struct_num
    READ_LONG  0x5c struct_off
    SET struct_length = 0xc4
    SET door_internal = 0
  END
  PATCH_IF door_internal < 0 BEGIN 
    PATCH_PRINT ~ == No changes made with cd_define_area_vertices: Unknown structure type specified (%struct_type%)~
  END ELSE BEGIN  
    SET vert_delta = 0 
    READ_LONG  0x7c vert_off
    READ_SHORT 0x80 vert_num
    FOR (index = 0 ; index < struct_num ; ++index) BEGIN
      READ_ASCII (struct_off + 0x00 + (index * struct_length)) name_check
      PATCH_IF ("%name_check%" STRING_COMPARE_CASE "%struct_name%") BEGIN // NOT the matched door/region/container
        PATCH_IF vert_delta != 0 BEGIN // don't bother if number of vertices hasn't changed (yet)
          PATCH_IF door_internal = 0 BEGIN // update container/region
            WRITE_LONG (struct_off + local_vert_idx_off + (index * struct_length)) THIS + vert_delta // update vertex index
          END ELSE BEGIN // update four door indices
            WRITE_LONG (struct_off + 0x2c + (index * struct_length)) THIS + vert_delta // open door vertex index
            WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed door vertex index
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta // impeded-open door vertex index
            WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta // impeded-closed door vertex index
          END    
        END  
      END ELSE BEGIN // matched door/region/container
        PATCH_IF local_bound_off != 0 BEGIN // skip for impeded doors
          PATCH_IF bounding_left >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x00 + (index * struct_length)) bounding_left   // set the new bounding box
          END  
          PATCH_IF bounding_top >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x02 + (index * struct_length)) bounding_top    // set the new bounding box
          END  
          PATCH_IF bounding_right >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x04 + (index * struct_length)) bounding_right  // set the new bounding box
          END  
          PATCH_IF bounding_bottom >= 0 BEGIN // only if set
            WRITE_SHORT (struct_off + local_bound_off + 0x06 + (index * struct_length)) bounding_bottom // set the new bounding box
          END  
        END  
        PATCH_IF launch_point_x >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x00 + (index * struct_length)) launch_point_x    // set the new x launch coordinates
        END  
        PATCH_IF launch_point_y >= 0 BEGIN // only if set
          WRITE_SHORT (struct_off + local_launch_off + 0x02 + (index * struct_length)) launch_point_y    // set the new y launch coordinates
        END  
        READ_LONG   (struct_off + local_vert_idx_off + (index * struct_length)) struct_vert_idx      
        READ_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num    
        PATCH_IF struct_vert_num != 0 BEGIN // delete old vertices first
          DELETE_BYTES (vert_off + (0x04 * struct_vert_idx)) (struct_vert_num * 0x04)
          SET vert_delta -= struct_vert_num
          SET struct_vert_num = 0
        END
        PATCH_PHP_EACH cd_define_area_vertices_array AS coords => foo BEGIN
          INSERT_BYTES (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) 0x04   
          WRITE_SHORT  (vert_off + 0x00 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_0      
          WRITE_SHORT  (vert_off + 0x02 + (0x04 * (struct_vert_num + struct_vert_idx))) coords_1      
          SET struct_vert_num += 1    
          SET vert_delta += 1
        END   
        WRITE_SHORT  (struct_off + local_vert_num_off + (index * struct_length)) struct_vert_num  
        // since doors have four vertex indices, may need additional vertex index updates for anything other than the last one (impeded-closed)
        PATCH_IF door_internal > 1 BEGIN      // impeded-open, closed, or open
          WRITE_LONG (struct_off + 0x50 + (index * struct_length)) THIS + vert_delta     // impeded-closed index
          PATCH_IF door_internal > 2  BEGIN   // closed or open
            WRITE_LONG (struct_off + 0x48 + (index * struct_length)) THIS + vert_delta   // impeded-open index
            PATCH_IF door_internal > 3  BEGIN // open                                         
              WRITE_LONG (struct_off + 0x34 + (index * struct_length)) THIS + vert_delta // closed index 
            END
          END
        END // bonus door check 
      END // match name check     
    END // end structure loop
    
    // now, to check everything else that uses vertices and update their indices if are listed after the new insertions/deletions
    PATCH_IF vert_delta != 0 BEGIN // don't bother if same number of vertices
      PATCH_FOR_EACH offset IN 0x54 0x5c 0x60 0x68 0x70 0x78 /* 0x7c */ 0x84 0x88 0x90 0xa0 0xa8 0xb0 0xb8 0xbc 0xc0 0xc4 0xcc BEGIN
        READ_LONG offset off_check
        PATCH_IF off_check > vert_off BEGIN // if section is after vertices, adjust accordingly
          WRITE_LONG offset (THIS + (0x04 * vert_delta)) 
        END
      END      
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "region") BEGIN // update region indices for containers/door patches
        READ_SHORT 0x5a region_num 
        READ_LONG  0x5c region_off
        FOR (index = 0 ; index < region_num ; ++index) BEGIN
          READ_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN 
            WRITE_LONG (region_off + 0x2c + (index * 0xc4)) vert_idx + vert_delta
          END
        END   
      END  
      PATCH_IF ("%struct_type%" STRING_COMPARE_CASE "container") BEGIN // update container indices for region/door patches
        READ_SHORT 0x74 cont_num 
        READ_LONG  0x70 cont_off
        FOR (index = 0 ; index < cont_num ; ++index) BEGIN
          READ_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx
          PATCH_IF vert_idx > struct_vert_idx BEGIN 
            WRITE_LONG (cont_off + 0x50 + (index * 0xc0)) vert_idx + vert_delta
          END
        END    
      END  
      PATCH_IF !door_internal BEGIN // update door indices for container/region patches
        READ_LONG 0xa4 door_num 
        READ_LONG 0xa8 door_off
        FOR (index = 0 ; index < door_num ; ++index) BEGIN
          PATCH_FOR_EACH local_off IN 0x2c 0x34 0x48 0x50 BEGIN // checks open door index, closed door index, impeded-open index, impeded-closed index
            READ_LONG (door_off + local_off + (index * 0xc8)) vert_idx
            PATCH_IF vert_idx > struct_vert_idx BEGIN 
              WRITE_LONG (door_off + local_off + (index * 0xc8)) vert_idx + vert_delta
            END
          END  
        END    
      END   
      WRITE_SHORT 0x80 vert_num + vert_delta
    END // vert_delta check  
    
  END // end valid structure check
  
END

/////                                                  \\\\\
///// cd_swap_actor_name                               \\\\\
/////                                                  \\\\\

DEFINE_ACTION_FUNCTION cd_swap_actor_name
  STR_VAR old_name = ""
          new_name = ""
          area     = ""
BEGIN
    
  ACTION_IF (("%old_name%" STRING_COMPARE_CASE "") AND (FILE_EXISTS_IN_GAME ~%area%.are~)) BEGIN
  
    COPY_EXISTING ~%area%.are~ ~override~
      READ_LONG  0x54 act_off
      READ_SHORT 0x58 act_num
      FOR (index = 0 ; index < act_num ; ++index) BEGIN
        READ_ASCII (act_off + 0x00 + (index * 0x110)) name (32) NULL
        PATCH_IF ("%old_name%" STRING_COMPARE_CASE "%name%" = 0) BEGIN
          WRITE_ASCIIE (act_off + 0x00 + (index * 0x110)) ~%new_name%~ #32
          SET index = act_num // kill loop
        END
      END
      BUT_ONLY
      
  END

END  

/////                                                  \\\\\
///// cd_bulk_fix_item_strings_bulk                    \\\\\
/////                                                  \\\\\

// mini-macro for the bulk item fixes, string updates
DEFINE_PATCH_MACRO cd_bulk_fix_item_strings_bulk BEGIN

  FOR (index = 0x54 ; index > 0x4f ; index -= 0x04) BEGIN // only if no identified descript to match and update, go after normal descript (blun04)
    READ_LONG index desc_strref
    PATCH_IF ((desc_strref >= 0) AND (desc_strref < 999999)) BEGIN
      READ_STRREF index desc
      INNER_PATCH_SAVE desc ~%desc%~ BEGIN
        PATCH_IF (IS_AN_INT params_4) BEGIN 
          REPLACE_TEXTUALLY ~%itm_speed_text%~ ~\1%params_4%~
        END 
        PATCH_IF (IS_AN_INT params_5) BEGIN 
          REPLACE_TEXTUALLY ~%itm_weight_text%~ ~\1%params_5%~
        END 
        PATCH_IF (IS_AN_INT params_6) BEGIN 
          REPLACE_TEXTUALLY ~%itm_thac0_text%~ ~\1%params_6%~
        END 
      END
      INNER_ACTION BEGIN
        STRING_SET_EVALUATE desc_strref ~%desc%~
      END
      SET index = 0 // kill loop (if identified updated, don't mess with unidentified)
    END
  END

END